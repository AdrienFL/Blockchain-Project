\documentclass{article}
\usepackage{etex}
\usepackage{amsmath}
\usepackage{pdfpages}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{pgf-umlsd}
\usepackage{pgfplots}
\usepackage{geometry}
\geometry{
	a4paper,
	left=25.4mm,
	right=25.4mm,
	top=25mm,
	bottom=25.4mm
	}
\begin{document}

\includepdf{title.pdf}

\tableofcontents
\listoffigures

\newpage

\section{Why Paxos?}
Paxos is a consensus algorithm that allows a group of processes to agree on a single value, even in the presence of failures. It is designed to work in asynchronous distributed systems, where processes may fail or messages may be lost. Paxos is widely used in distributed systems for achieving fault tolerance and ensuring consistency.
The algorithm is based on the idea of "proposers" that suggest values, "acceptors" that vote on one of the proposed values, and "learners" that learn the agreed-upon value. The algorithm ensures that even if some processes fail, as long as a majority of processes are functioning, they can still reach consensus.
Paxos is particularly useful in scenarios where a distributed system needs to maintain a consistent state across multiple nodes, such as in databases, distributed file systems, and cloud computing platforms. It provides a robust and reliable way to achieve consensus, making it a popular choice for building fault-tolerant distributed systems.

\section{Java Implementation of the Robust Key-Value Store}

\subsection{Java classes}
For our implementation with Java and the Akka framework, we have created the following classes:

\begin{itemize}
    \item \texttt{Main}: The main class that creates the different actors and configures the system. It is also the class that computes the statistics at the end of the simulation.

    \item \texttt{Process}: The actor class. The obstruction-free consensus algorithm is implemented in this class.

    \item \texttt{AbortMsg}: The class that represents the abort message sent between the processes.

    \item \texttt{AckMsg}: The class that represents the acknowledgment (ACK) message sent between the processes.

    \item \texttt{CrashMsg}: The class that represents the crash message sent between the processes. When a process receives a crash message, it will enter in the fault-prune mode.

    \item \texttt{DecideMsg}: The class that represents the decide message sent between the processes.

    \item \texttt{GatherMsg}: The class that represents the GATHER message sent between the processes.

    \item \texttt{ImposeMsg}: The class that represents the IMPOSE message sent between the processes.

    \item \texttt{Members}: The class that contains the processes' references.

    \item \texttt{Pair}:

    \item \texttt{ReadMsg}: The class that represents the read message sent between the processes.
\end{itemize}

We didn't want to use multiple threads in the \texttt{Process} class due to the large number of processes
being launched. It is more efficient to let the Akka framework's logic thread handle the processes.
Therefore, we implemented a state machine in the \texttt{Process} class to manage the different states
of the functions: sending the initial read request, waiting for a quorum of responses, sending the
write request, and finally, waiting for a quorum of write acknowledgments.


\newpage
\subsection{Akka Design}

\begin{figure}[h!]
\centering

\begin{sequencediagram}
    \newthread{main}{main}
    \newinst{a}{Correct Process  A}
    \newinst[1]{b}{Correct Process B}
    \newinst[1]{c}{Failed Process C}

    \mess{main}{refs}{a}
    \mess{main}{refs}{b}
    \mess{main}{refs}{c}
    \mess{main}{crash}{c}
    \mess{main}{launch}{a}
    \mess{main}{launch}{b}
    \begin{sdblock}{write}{B Writes}
        \begin{call}{b}{Read request}{a}{Read response (ts)}
        \end{call}
        \begin{call}{b}{Write request (val, ts)}{a}{Write ack}
        \end{call}
    \end{sdblock}
    \begin{sdblock}{read}{A reads}
        \begin{call}{a}{Read request}{b}{Read response (val, ts)}
        \end{call}
        \begin{call}{a}{Write request (val, ts)}{b}{Write ack}
        \end{call}
    \end{sdblock}
    \mess{a}{done, stats}{main}
    \mess{b}{done, stats}{main}
\end{sequencediagram}

\caption{Sequence diagram of the Akka design}
\end{figure}
\newpage
\subsection{Statistics computation}

TODO

Throughout the simulation, the processes continuously collect data for
the statistics. At the end of the simulation, the main class will compute this data:

% \begin{itemize}
%     \item The time taken for each process to complete a write operation.
%     \item The time taken for each process to complete a read operation.
%     \item The average time spend by a process to complete all the write operations.
%     \item The average time spend by a process to complete all the read operations.
%     \item The throughput of the system.
% \end{itemize}

For the throughput, we have used the formula :
$$
\text{Throughput} = \frac{\text{Number of operations}}{\text{Total time}}
$$

\newpage

\section{Performance analysis}
The simulation has different parameters that can be changed to test the performance of the system. The main parameters are:

\begin{itemize}
    \item $N$ The number of processes and $f$ the number of processes which can fail.
    \item $t_{le}$ The fixed timeout.
    \item $\alpha$ The probability of failure of a process.
\end{itemize}

Since we need a quorum, $f$ must be less than $N/2$. Thus,
we have different scenarios to test the performance of the simulation
with $(N,f) \in \{(3,1),(10,4),(100,49)\}$, $t_{le} \in \{0.5,1,1.5,2\}$ and $\alpha \in \{0,0.1,1\}$.

\subsection{Results for a fixed timeout $t_{le}$}
Let's now analyze the results for a fixed timeout $t_{le}$ and different values of $N$.

\begin{figure}[h!]
    \centering
    \begin{subfigure}{0.55\textwidth}
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Number of processes},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={3, 10, 100},
            ymin=0, ymax=6,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(3, 0.4) (10, 0.5) (100, 4.9)};
        \addlegendentry{$t_{le} = 500$}
        \addplot coordinates {(3, 0.6) (10, 0.3) (100, 3.7)};
        \addlegendentry{$t_{le} = 1000$}
        \addplot coordinates {(3, 0.2) (10, 0.3) (100, 0.9)};
        \addlegendentry{$t_{le} = 1500$}
        \addplot coordinates {(3, 0.0) (10, 0.2) (100, 5.1)};
        \addlegendentry{$t_{le} = 2000$}
        \end{axis}
    \end{tikzpicture}
    \caption{Mean latency comparison for $\alpha = 0$}
\end{subfigure}%
\begin{subfigure}{.55\textwidth}
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Number of processes},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={3, 10, 100},
            ymin=0, ymax=6,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(3, 0.3) (10, 0.4) (100, 1.3)};
        \addlegendentry{$t_{le} = 500$}
        \addplot coordinates {(3, 0.5) (10, 0.1) (100, 0.4)};
        \addlegendentry{$t_{le} = 1000$}
        \addplot coordinates {(3, 0.3) (10, 0.4) (100, 1.1)};
        \addlegendentry{$t_{le} = 1500$}
        \addplot coordinates {(3, 0.2) (10, 0.3) (100, 0.3)};
        \addlegendentry{$t_{le} = 2000$}
        \end{axis}
    \end{tikzpicture}
    \caption{Mean latency comparison for $\alpha = 0.1$}
\end{subfigure}
\begin{subfigure}{.55\textwidth}
    \vspace{1cm}
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Number of processes},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={3, 10, 100},
            ymin=0, ymax=6,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(3, 2.3) (10, 0.7) (100, 2.8)};
        \addlegendentry{$t_{le} = 500$}
        \addplot coordinates {(3, 0.1) (10, 2.7) (100, 1.0)};
        \addlegendentry{$t_{le} = 1000$}
        \addplot coordinates {(3, 0.5) (10, 0.2) (100, 0.9)};
        \addlegendentry{$t_{le} = 1500$}
        \addplot coordinates {(3, 2.7) (10, 0.4) (100, 0.5)};
        \addlegendentry{$t_{le} = 2000$}
        \end{axis}
    \end{tikzpicture}
    \caption{Mean latency comparison for $\alpha = 1$}
\end{subfigure}
\caption{Mean latency comparison for fixed timeout and alpha values and different number of processes}
\end{figure}

\newpage

\subsection{Results for a fixed number of processes}
Let's first analyze the results for a fixed number of processes $N$ and different values of $t_{le}$.

\begin{figure}[h!]
    \centering
    \begin{subfigure}{0.55\textwidth}
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Timeout (ms)},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={500, 1000, 1500, 2000},
            ymin=0, ymax=6,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(500, 0.4) (1000, 0.6) (1500, 0.2) (2000, 0.0)};
        \addlegendentry{$N = 3$}
        \addplot coordinates {(500, 0.5) (1000, 0.3) (1500, 0.3) (2000, 0.2)};
        \addlegendentry{$N = 10$}
        \addplot coordinates {(500, 4.9) (1000, 3.7) (1500, 0.9) (2000, 5.1)};
        \addlegendentry{$N = 100$}
        \end{axis}
    \end{tikzpicture}
    \caption{Mean latency comparison for $\alpha = 0$}
\end{subfigure}%
\begin{subfigure}{.55\textwidth}
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Timeout (ms)},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={500, 1000, 1500, 2000},
            ymin=0, ymax=6,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(500, 0.3) (1000, 0.5) (1500, 0.3) (2000, 0.2)};
        \addlegendentry{$N = 3$}
        \addplot coordinates {(500, 0.4) (1000, 0.1) (1500, 0.4) (2000, 0.3)};
        \addlegendentry{$N = 10$}
        \addplot coordinates {(500, 1.3) (1000, 0.4) (1500, 1.1) (2000, 0.3)};
        \addlegendentry{$N = 100$}
        \end{axis}
    \end{tikzpicture}
    \caption{Mean latency comparison for $\alpha = 0.1$}
\end{subfigure}
\begin{subfigure}{.55\textwidth}
    \vspace{1cm}
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Timeout (ms)},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={500, 1000, 1500, 2000},
            ymin=0, ymax=6,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(500, 2.3) (1000, 0.1) (1500, 0.5) (2000, 2.7)};
        \addlegendentry{$N = 3$}
        \addplot coordinates {(500, 0.7) (1000, 2.7) (1500, 0.2) (2000, 0.4)};
        \addlegendentry{$N = 10$}
        \addplot coordinates {(500, 2.8) (1000, 1.0) (1500, 0.9) (2000, 0.5)};
        \addlegendentry{$N = 100$}
        \end{axis}
    \end{tikzpicture}
    \caption{Mean latency comparison for $\alpha = 1$}
\end{subfigure}
\caption{Mean latency comparison for fixed number of processes and alpha values}
\end{figure}

\newpage

\subsection{Results for the probability of failure}
Let's now analyze the results for fixed numbers of processes $N$ and timeout $t_{le}$, with different probabilities of failure $\alpha$.

\subsubsection{Results for \(N = 3\)}

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Probability of failures ($\alpha$)},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={0, 0.1, 1},
            ymin=0, ymax=3,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(0, 0.4) (0.1, 0.3) (1, 2.3)};
        \addlegendentry{$t_{le} = 500$}
        \addplot coordinates {(0, 0.6) (0.1, 0.5) (1, 0.1)};
        \addlegendentry{$t_{le} = 1000$}
        \addplot coordinates {(0, 0.2) (0.1, 0.3) (1, 0.5)};
        \addlegendentry{$t_{le} = 1500$}
        \addplot coordinates {(0, 0.0) (0.1, 0.2) (1, 2.7)};
        \addlegendentry{$t_{le} = 2000$}
        \end{axis}
    \end{tikzpicture}
\caption{Mean latency for \( N = 3 \)}
\end{figure}

\newpage

\subsubsection{Results for \(N = 10\)}

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Probability of failures ($\alpha$)},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={0, 0.1, 1},
            ymin=0, ymax=3,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(0, 0.5) (0.1, 0.4) (1, 0.7)};
        \addlegendentry{$t_{le} = 500$}
        \addplot coordinates {(0, 0.3) (0.1, 0.1) (1, 2.7)};
        \addlegendentry{$t_{le} = 1000$}
        \addplot coordinates {(0, 0.3) (0.1, 0.4) (1, 0.2)};
        \addlegendentry{$t_{le} = 1500$}
        \addplot coordinates {(0, 0.2) (0.1, 0.3) (1, 0.4)};
        \addlegendentry{$t_{le} = 2000$}
        \end{axis}
    \end{tikzpicture}
\caption{Mean latency for \( N = 10 \)}
\end{figure}

\newpage

\subsubsection{Results for \(N = 100\)}

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Probability of failures ($\alpha$)},
            ylabel={Mean Latency (ms)},
            xtick=data,
            symbolic x coords={0, 0.1, 1},
            ymin=0, ymax=6,
            ymajorgrids=true,
            grid style=dashed
        ]
        \addplot coordinates {(0, 4.9) (0.1, 1.3) (1, 2.8)};
        \addlegendentry{$t_{le} = 500$}
        \addplot coordinates {(0, 3.7) (0.1, 0.4) (1, 1.0)};
        \addlegendentry{$t_{le} = 1000$}
        \addplot coordinates {(0, 0.9) (0.1, 1.1) (1, 0.9)};
        \addlegendentry{$t_{le} = 1500$}
        \addplot coordinates {(0, 5.1) (0.1, 0.3) (1, 0.5)};
        \addlegendentry{$t_{le} = 2000$}
        \end{axis}
    \end{tikzpicture}
\caption{Mean latency for \( N = 100 \)}
\end{figure}

\section{Conclusion}
% In conclusion, we can say that the configuration with 3 processes is more
% efficient for a small number of operations, while the configuration with 100
% processes is more efficient for a large number of operations. The configuration
% with 10 processes lies in between.

% If we were to implement this system in a real-life scenario, we would need to
% consider the number of operations to be processed and the acceptable latency.
% Server characteristics and network capacity may also impose constraints that
% influence the choice of the optimal configuration. The configuration with 10
% processes could be a good compromise between the other two in many situations,
% as it is sufficiently efficient for handling both small and large numbers of requests.
\end{document}

